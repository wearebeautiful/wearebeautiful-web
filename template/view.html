{%- extends 'base.html' -%}
{%- block content -%}
    <div class="row" id="info-row">
        <div id="model" class="h-100"></div>
        <div id="progress" class="col-6">
           Loading ...
        </div>
        <div id="view-info" class="col-6 text-right">
           {% if model.body_part != "anatomical" %}
             {{ model.body_part }} of a {{ model.gender }} with a {{ model.body_type }} body.
           {% else %}
              anatomical model
           {% endif %}
        </div>
    </div>
{% endblock%}

{% block scripts %}
{{ bootstrap.load_js() }}
<script type="module">

       	import * as THREE from '/static/js/node_modules/three/build/three.module.js';
       	import { STLLoader } from '/static/js/node_modules/three/examples/jsm/loaders/STLLoader.js';
        import { OrbitControls } from '/static/js/node_modules/three/examples/jsm/controls/OrbitControls.js';

       	var container;
       	var camera, scene, renderer, controls;
        var v_offset;

       	init();
       	animate();

       	function init() {

                // I have no idea how to compute the correct size so that the whole div area is taken and no scroll bars appear.
                v_offset = 87; //$("#model").position().top;

       		camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 1, 15 );
       		camera.position.set( 3, 0.15, 3 );

       		scene = new THREE.Scene();
       		scene.background = new THREE.Color( 0xEEEEEE );

       		var material = new THREE.MeshPhongMaterial( { color: 0x6A0080, specular: 0x111111, shininess: 50 } );
                material.side = THREE.DoubleSide;

                var loader = new STLLoader();
       		loader.load( '{{ model_file }}', function ( geometry ) {

                        geometry.computeFaceNormals();
                        geometry.computeVertexNormals();
                        geometry.computeBoundingBox();
                        var scale_factor = 1.0 / geometry.boundingBox.max.y;

       			var mesh = new THREE.Mesh( geometry, material );
       			mesh.scale.set(scale_factor, scale_factor, scale_factor);

       			mesh.castShadow = false;
       			mesh.receiveShadow = false;

       			scene.add( mesh );
                        $("#progress").text("{{ model.model_id }}-{{ model.code }}");
       		} );

       		// Lights
       		scene.add( new THREE.HemisphereLight( 0x333333, 0x111111 ) );

       		addShadowedLight( 2, 2, 2, 0xffffff, .4 );
       		addShadowedLight( 2, 2, -2, 0xffffff, .4 );
       		addShadowedLight( -2, 2, 2, 0xffffff, .4 );
       		addShadowedLight( -2, 2, -2, 0xffffff, .4 );
       		addShadowedLight( 0, -2, 0, 0xffffff, .2 );

       		// renderer
       		renderer = new THREE.WebGLRenderer( { antialias: true } );
       		renderer.setPixelRatio( window.devicePixelRatio );
       		renderer.setSize( window.innerWidth, window.innerHeight - v_offset );
       		renderer.outputEncoding = THREE.sRGBEncoding;

       		renderer.shadowMap.enabled = true;

                controls = new OrbitControls( camera, renderer.domElement );
                controls.autoRotateSpeed = 3.0;
                controls.autoRotate = true;
		controls.enableDamping = true;
		controls.dampingFactor = 0.05;

      		$("#model").append( renderer.domElement );

       		window.addEventListener( 'resize', onWindowResize, false );

       	}

       	function addShadowedLight( x, y, z, color, intensity ) {

       		var directionalLight = new THREE.DirectionalLight( color, intensity );
       		directionalLight.position.set( x, y, z );
       		scene.add( directionalLight );

       		directionalLight.castShadow = true;

       		var d = 1;
       		directionalLight.shadow.camera.left = - d;
       		directionalLight.shadow.camera.right = d;
       		directionalLight.shadow.camera.top = d;
       		directionalLight.shadow.camera.bottom = - d;

       		directionalLight.shadow.camera.near = 1;
       		directionalLight.shadow.camera.far = 4;

       		directionalLight.shadow.bias = - 0.002;

       	}

       	function onWindowResize() {
       		camera.aspect = window.innerWidth / window.innerHeight;
       		camera.updateProjectionMatrix();
      		renderer.setSize( window.innerWidth, window.innerHeight - v_offset );
       	}

       	function animate() {
       		requestAnimationFrame( animate );
       		render();
       	}

       	function render() {
                controls.update();
       		renderer.render( scene, camera );
       	}

       </script>
</script>
{% endblock %}
